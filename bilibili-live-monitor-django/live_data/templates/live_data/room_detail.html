<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æˆ¿é—´ {{ room_id }} - Bilibili ç›´æ’­ç›‘æ§</title>
    <style>
        body { 
            font-family: 'Microsoft YaHei', Arial, sans-serif; 
            margin: 0; 
            padding: 20px; 
            background: #f5f5f5; 
            line-height: 1.4;
        }
        .container { max-width: 1400px; margin: 0 auto; }
        .header { 
            background: white; 
            padding: 20px; 
            border-radius: 8px; 
            margin-bottom: 20px; 
            box-shadow: 0 2px 4px rgba(0,0,0,0.1); 
            position: relative;
        }
        .room-cover {
            width: 120px;
            height: 68px;
            border-radius: 6px;
            object-fit: cover;
            float: left;
            margin-right: 20px;
            border: 2px solid #ddd;
        }
        .room-basic-info {
            overflow: hidden;
        }
        .room-title {
            font-size: 1.5em;
            font-weight: bold;
            margin-bottom: 10px;
            color: #333;
        }
        .room-subtitle {
            color: #666;
            margin-bottom: 5px;
        }
        .status-indicator { 
            position: absolute;
            top: 20px;
            right: 20px;
            padding: 8px 12px; 
            border-radius: 6px; 
            font-size: 0.9em; 
            font-weight: 500;
        }
        .status-connected { background: #d4edda; color: #155724; }
        .status-error { background: #f8d7da; color: #721c24; }
        .status-warning { background: #fff3cd; color: #856404; }
        
        .grid { 
            display: grid; 
            grid-template-columns: 1fr 1fr; 
            gap: 20px; 
            margin-bottom: 20px;
        }
        .grid.three-col {
            grid-template-columns: repeat(3, 1fr);
        }
        .card { 
            background: white; 
            padding: 20px; 
            border-radius: 8px; 
            box-shadow: 0 2px 4px rgba(0,0,0,0.1); 
            position: relative;
        }
        .card h3 {
            margin-top: 0;
            margin-bottom: 15px;
            color: #333;
            border-bottom: 2px solid #f0f0f0;
            padding-bottom: 10px;
        }
        
        .stats-grid { 
            display: grid; 
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); 
            gap: 15px; 
            margin: 15px 0; 
        }
        .stat-item { 
            text-align: center; 
            padding: 15px; 
            background: #f8f9fa; 
            border-radius: 6px; 
            border: 2px solid transparent;
            transition: all 0.3s ease;
        }
        .stat-item.updated {
            border-color: #28a745;
            background: #d4edda;
            transform: scale(1.02);
        }
        .stat-number { 
            font-size: 1.8em; 
            font-weight: bold; 
            color: #007cba; 
            transition: color 0.3s ease;
        }
        .stat-number.updated {
            color: #28a745;
        }
        .stat-label { 
            color: #666; 
            font-size: 0.85em; 
            margin-top: 5px; 
        }
        
        .danmaku-item, .gift-item { 
            padding: 12px; 
            border: 1px solid #e9ecef; 
            border-radius: 6px; 
            margin-bottom: 8px; 
            transition: all 0.3s ease;
            background: white;
            opacity: 0;
            transform: translateY(-20px);
            animation: slideInFromTop 0.5s ease-out forwards;
        }
        
        .danmaku-item:hover, .gift-item:hover {
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            transform: translateY(-1px);
        }
        
        .danmaku-item.new, .gift-item.new {
            border-color: #28a745;
            background: linear-gradient(90deg, #f8fff9, #e8f5e8);
            animation: slideInFromTop 0.5s ease-out forwards, newItemPulse 2s ease-out;
            box-shadow: 0 0 10px rgba(40, 167, 69, 0.3);
        }
        
        .danmaku-user, .gift-user {
            font-weight: bold;
            color: #007cba;
            margin-right: 8px;
        }
        .danmaku-message {
            color: #333;
        }
        .danmaku-time, .gift-time {
            font-size: 0.8em;
            color: #666;
            float: right;
        }
        .gift-info {
            color: #e91e63;
            font-weight: 500;
        }
        
        .control-panel { 
            background: #f8f9fa; 
            padding: 15px; 
            border-radius: 6px; 
            margin-bottom: 20px; 
            border: 1px solid #dee2e6;
        }
        .control-row { 
            display: flex; 
            gap: 10px; 
            align-items: center; 
            margin: 8px 0; 
            flex-wrap: wrap; 
        }
        .control-label { 
            min-width: 80px; 
            font-weight: 500; 
            color: #495057;
        }
        
        .btn { 
            padding: 8px 16px; 
            background: #007cba; 
            color: white; 
            border: none; 
            border-radius: 4px; 
            cursor: pointer; 
            text-decoration: none;
            display: inline-block; 
            margin: 2px; 
            font-size: 0.9em;
            transition: all 0.3s ease;
        }
        .btn:hover { 
            background: #005a8b; 
            transform: translateY(-1px);
        }
        .btn.small { padding: 6px 12px; font-size: 0.8em; }
        .btn.success { background: #28a745; }
        .btn.success:hover { background: #1e7e34; }
        .btn.warning { background: #ffc107; color: #212529; }
        .btn.warning:hover { background: #e0a800; }
        .btn.danger { background: #dc3545; }
        .btn.danger:hover { background: #c82333; }
        
        .refresh-indicator { 
            display: inline-block; 
            padding: 5px 10px; 
            border-radius: 4px; 
            font-size: 0.8em; 
            margin-left: 10px; 
            transition: all 0.3s ease;
        }
        .refresh-indicator.active { background: #28a745; color: white; }
        .refresh-indicator.paused { background: #ffc107; color: #212529; }
        
        .message-box {
            padding: 12px;
            border-radius: 4px;
            margin: 10px 0;
            font-weight: 500;
        }
        .message-box.success { background: #d4edda; color: #155724; border: 1px solid #c3e6cb; }
        .message-box.error { background: #f8d7da; color: #721c24; border: 1px solid #f5c6cb; }
        .message-box.warning { background: #fff3cd; color: #856404; border: 1px solid #ffeaa7; }
        .message-box.info { background: #d1ecf1; color: #0c5460; border: 1px solid #bee5eb; }
        
        .loading-spinner {
            display: inline-block;
            width: 16px;
            height: 16px;
            border: 2px solid #f3f3f3;
            border-top: 2px solid #007cba;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            vertical-align: middle;
            margin-left: 8px;
        }
        
        /* æ ¸å¿ƒæ”¹è¿›ï¼šå¼¹å¹•å®¹å™¨æ ·å¼ */
        .data-container {
            height: 400px; /* å›ºå®šé«˜åº¦ */
            overflow-y: auto;
            border: 1px solid #e9ecef;
            border-radius: 6px;
            padding: 10px;
            background: #fafafa;
            position: relative;
            display: flex;
            flex-direction: column-reverse; /* å…³é”®ï¼šåå‘æ’åˆ—ï¼Œæ–°å†…å®¹åœ¨ä¸Šæ–¹ */
        }
        
        /* å¼¹å¹•å®¹å™¨å†…å®¹åŒºåŸŸ */
        .danmaku-list, .gift-list {
            display: flex;
            flex-direction: column-reverse; /* æ–°æ¶ˆæ¯åœ¨é¡¶éƒ¨ */
            min-height: min-content;
        }
        
        /* å›ºå®šæ»šåŠ¨æ¡ä½ç½® */
        .data-container::-webkit-scrollbar {
            width: 8px;
        }
        
        .data-container::-webkit-scrollbar-track {
            background: #f1f1f1;
            border-radius: 4px;
        }
        
        .data-container::-webkit-scrollbar-thumb {
            background: #888;
            border-radius: 4px;
        }
        
        .data-container::-webkit-scrollbar-thumb:hover {
            background: #555;
        }
        
        /* è‡ªåŠ¨ç½®é¡¶æŒ‡ç¤ºå™¨ */
        .auto-scroll-indicator {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0, 124, 186, 0.9);
            color: white;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 0.7em;
            opacity: 0;
            transition: opacity 0.3s ease;
            pointer-events: none;
            z-index: 10;
        }
        
        .auto-scroll-indicator.show {
            opacity: 1;
        }

        .uploader-info {
            display: flex;
            align-items: center;
            margin-bottom: 15px;
        }

        .uploader-avatar {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            object-fit: cover;
            margin-right: 15px;
            border: 3px solid #ddd;
        }

        .room-cover {
            width: 120px;
            height: 68px;
            border-radius: 6px;
            object-fit: cover;
            margin-right: 20px;
            border: 2px solid #ddd;
        }

        .verified-badge {
            font-size: 0.8em;
            margin-left: 8px;
            color: #28a745;
        }

        .room-meta {
            color: #666;
            margin: 8px 0;
            font-size: 0.9em;
        }

        .uploader-links {
            margin-top: 10px;
        }

        .uploader-links .btn {
            margin-right: 8px;
            font-size: 0.8em;
            padding: 4px 8px;
        }

        .empty-state {
            text-align: center;
            color: #666;
            padding: 40px 20px;
            background: #f8f9fa;
            border-radius: 6px;
            border: 1px dashed #dee2e6;
            margin: auto; /* åœ¨ flex-direction: column-reverse ä¸­å±…ä¸­ */
        }
        
        .last-update {
            font-size: 0.8em;
            color: #666;
            text-align: right;
            margin-top: 10px;
        }
        
        /* æ»šåŠ¨æ§åˆ¶æŒ‰é’® */
        .scroll-controls {
            position: absolute;
            bottom: 10px;
            right: 10px;
            display: flex;
            gap: 5px;
            z-index: 10;
        }
        
        .scroll-btn {
            width: 30px;
            height: 30px;
            border: none;
            border-radius: 50%;
            background: rgba(0, 124, 186, 0.8);
            color: white;
            cursor: pointer;
            font-size: 0.8em;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .scroll-btn:hover {
            background: rgba(0, 124, 186, 1);
            transform: scale(1.1);
        }
        
        .scroll-btn.disabled {
            background: rgba(108, 117, 125, 0.5);
            cursor: not-allowed;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        @keyframes slideInFromTop {
            0% { 
                opacity: 0; 
                transform: translateY(-20px); 
            }
            100% { 
                opacity: 1; 
                transform: translateY(0); 
            }
        }
        
        @keyframes newItemPulse {
            0%, 100% { 
                box-shadow: 0 0 10px rgba(40, 167, 69, 0.3); 
            }
            50% { 
                box-shadow: 0 0 20px rgba(40, 167, 69, 0.6); 
            }
        }
        
        /* å“åº”å¼è®¾è®¡ */
        @media (max-width: 768px) {
            .container { padding: 10px; }
            .grid { grid-template-columns: 1fr; }
            .grid.three-col { grid-template-columns: 1fr; }
            .stats-grid { grid-template-columns: repeat(2, 1fr); }
            .room-cover { 
                width: 80px; 
                height: 45px; 
                margin-bottom: 10px; 
            }
            .control-row { flex-direction: column; align-items: flex-start; }
            .data-container { height: 300px; } /* ç§»åŠ¨ç«¯ç¨å¾®é™ä½é«˜åº¦ */
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- é¡µé¢å¤´éƒ¨ -->
        <div class="header">
            <div class="uploader-info">
                {% if room_info.face %}
                    <img src="{{ room_info.face }}" alt="UPä¸»å¤´åƒ" class="uploader-avatar" onerror="this.style.display='none'">
                {% endif %}
                
                {% if room_info.cover %}
                    <img src="{{ room_info.cover }}" alt="ç›´æ’­å°é¢" class="room-cover" onerror="this.style.display='none'">
                {% endif %}
            </div>
            
            <div class="room-basic-info">
                <div class="room-title">
                    {{ room_info.uname|default:"æœªçŸ¥ä¸»æ’­" }}
                    {% if room_info.is_verified %}
                        <span class="verified-badge" title="{{ room_info.verify_desc }}">âœ…</span>
                    {% endif %}
                    <small style="color: #666;">({{ room_id }})</small>
                </div>
                
                <div class="room-subtitle">{{ room_info.title|default:"ç›´æ’­ä¸­..." }}</div>
                
                <div class="room-meta">
                    ğŸ“ {{ room_info.parent_area_name|default:"æœªçŸ¥" }} - {{ room_info.area_name|default:"æœªçŸ¥" }}
                    {% if room_info.gender_text %}
                        | ğŸ‘¤ {{ room_info.gender_text }}
                    {% endif %}
                    {% if room_info.attention %}
                        | ğŸ‘¥ {{ room_info.attention|floatformat:0 }} å…³æ³¨
                    {% endif %}
                    {% if room_info.live_status == 1 %}
                        <span style="color: #28a745; margin-left: 10px;">ğŸ”´ æ­£åœ¨ç›´æ’­</span>
                    {% endif %}
                </div>
                
                {% if room_info.uid %}
                <div class="uploader-links">
                    <a href="https://space.bilibili.com/{{ room_info.uid }}" target="_blank" class="btn small">
                        ğŸ‘¤ è®¿é—®UPä¸»é¡µ
                    </a>
                    <a href="https://live.bilibili.com/{{ room_id }}" target="_blank" class="btn small">
                        ğŸ“º è®¿é—®ç›´æ’­é—´
                    </a>
                </div>
                {% endif %}
            </div>
            
            <div class="status-indicator {% if redis_status == 'connected' %}status-connected{% else %}status-error{% endif %}" 
                 id="connection-status">
                {% if redis_status == 'connected' %}
                    âœ… è¿æ¥æ­£å¸¸
                {% else %}
                    âŒ è¿æ¥å¤±è´¥
                {% endif %}
            </div>
        </div>

        <!-- æ§åˆ¶é¢æ¿ -->
        <div class="control-panel">
            <div class="control-row">
                <span class="control-label">å¿«é€Ÿæ“ä½œ:</span>
                <a href="/live/" class="btn">â† è¿”å›ä»ªè¡¨æ¿</a>
                <button onclick="refreshAllData()" class="btn success">ğŸ”„ åˆ·æ–°æ•°æ®</button>
                <button onclick="clearAllData()" class="btn warning">ğŸ—‘ï¸ æ¸…ç©ºæ˜¾ç¤º</button>
            </div>
            
            <div class="control-row">
                <span class="control-label">å®æ—¶æ›´æ–°:</span>
                <button onclick="toggleAutoRefresh()" class="btn" id="auto-refresh-btn">â¸ï¸ æš‚åœ</button>
                <select id="refresh-interval" onchange="changeRefreshInterval()">
                    <option value="1000">1ç§’</option>
                    <option value="2000" selected>2ç§’</option>
                    <option value="5000">5ç§’</option>
                    <option value="10000">10ç§’</option>
                </select>
                <span class="refresh-indicator active" id="refresh-indicator">â±ï¸ è‡ªåŠ¨åˆ·æ–°: 2ç§’</span>
            </div>
            
            <div class="control-row">
                <span class="control-label">æ˜¾ç¤ºè®¾ç½®:</span>
                <label>
                    <input type="checkbox" id="auto-scroll-top" checked> æ–°æ¶ˆæ¯è‡ªåŠ¨ç½®é¡¶
                </label>
                <label>
                    <input type="checkbox" id="show-scroll-controls" checked> æ˜¾ç¤ºæ»šåŠ¨æ§åˆ¶
                </label>
                <label>
                    <input type="checkbox" id="highlight-new" checked> é«˜äº®æ–°æ¶ˆæ¯
                </label>
            </div>
            
            <div class="control-row">
                <span class="control-label">ç»Ÿè®¡:</span>
                <span id="update-counter">æ›´æ–°: 0</span>
                <span id="new-danmaku-counter">æ–°å¼¹å¹•: 0</span>
                <span id="new-gifts-counter">æ–°ç¤¼ç‰©: 0</span>
                <span id="last-update-time">æœ€åæ›´æ–°: --:--:--</span>
            </div>
        </div>

        <!-- æˆ¿é—´ç»Ÿè®¡ -->
        <div class="card">
            <h3>ğŸ“Š æˆ¿é—´ç»Ÿè®¡ <span class="loading-spinner" id="stats-loading" style="display: none;"></span></h3>
            
            <div class="stats-grid">
                <div class="stat-item" id="stat-danmaku-count">
                    <div class="stat-number" id="danmaku-count">{{ room_stats.danmaku_count|default:0 }}</div>
                    <div class="stat-label">å¼¹å¹•æ€»æ•°</div>
                </div>
                <div class="stat-item" id="stat-gift-count">
                    <div class="stat-number" id="gift-count">{{ room_stats.gift_count|default:0 }}</div>
                    <div class="stat-label">ç¤¼ç‰©æ€»æ•°</div>
                </div>
                <div class="stat-item" id="stat-popularity">
                    <div class="stat-number" id="popularity">{{ room_info.popularity|default:0 }}</div>
                    <div class="stat-label">äººæ°”å€¼</div>
                </div>
                <div class="stat-item" id="stat-live-time">
                    <div class="stat-number" id="live-time">{{ room_stats.duration|default:"--:--" }}</div>
                    <div class="stat-label">ç›‘æ§æ—¶é•¿</div>
                </div>
            </div>
            
            <div class="last-update" id="stats-last-update">
                {% if room_stats %}æ›´æ–°äº {{ room_stats.last_update_time|default:"æœªçŸ¥" }}{% endif %}
            </div>
        </div>

        <div class="grid">
            <!-- å®æ—¶å¼¹å¹• -->
            <div class="card">
                <h3>ğŸ’¬ å®æ—¶å¼¹å¹• 
                    <small id="danmaku-count-display">({{ recent_danmaku|length }})</small>
                    <span class="loading-spinner" id="danmaku-loading" style="display: none;"></span>
                </h3>
                
                <div class="data-container" id="danmaku-container">
                    <div class="auto-scroll-indicator" id="danmaku-scroll-indicator">æ–°æ¶ˆæ¯å·²ç½®é¡¶</div>
                    
                    <div class="scroll-controls" id="danmaku-scroll-controls">
                        <button class="scroll-btn" onclick="scrollToTop('danmaku-container')" title="æ»šåŠ¨åˆ°é¡¶éƒ¨">â†‘</button>
                        <button class="scroll-btn" onclick="scrollToBottom('danmaku-container')" title="æ»šåŠ¨åˆ°åº•éƒ¨">â†“</button>
                    </div>
                    
                    <div class="danmaku-list" id="danmaku-list">
                        {% if recent_danmaku %}
                            {% for danmaku in recent_danmaku %}
                            <div class="danmaku-item" data-id="{{ danmaku.id|default:forloop.counter }}">
                                <span class="danmaku-user">{{ danmaku.username|default:"åŒ¿åç”¨æˆ·" }}</span>
                                <span class="danmaku-message">{{ danmaku.message|default:"" }}</span>
                                <span class="danmaku-time">{{ danmaku.timestamp|default:"æœªçŸ¥æ—¶é—´" }}</span>
                            </div>
                            {% endfor %}
                        {% else %}
                            <div class="empty-state" id="danmaku-empty">
                                ğŸ“­ æš‚æ— å¼¹å¹•æ•°æ®<br>
                                <small>ç­‰å¾…å®æ—¶æ•°æ®æˆ–æ£€æŸ¥æ•°æ®æ”¶é›†å™¨çŠ¶æ€</small>
                            </div>
                        {% endif %}
                    </div>
                </div>
                
                <div class="last-update" id="danmaku-last-update">
                    æœ€åæ›´æ–°: <span id="danmaku-update-time">{{ now|date:"H:i:s" }}</span>
                </div>
            </div>

            <!-- å®æ—¶ç¤¼ç‰© -->
            <div class="card">
                <h3>ğŸ å®æ—¶ç¤¼ç‰© 
                    <small id="gifts-count-display">({{ recent_gifts|length }})</small>
                    <span class="loading-spinner" id="gifts-loading" style="display: none;"></span>
                </h3>
                
                <div class="data-container" id="gifts-container">
                    <div class="auto-scroll-indicator" id="gifts-scroll-indicator">æ–°æ¶ˆæ¯å·²ç½®é¡¶</div>
                    
                    <div class="scroll-controls" id="gifts-scroll-controls">
                        <button class="scroll-btn" onclick="scrollToTop('gifts-container')" title="æ»šåŠ¨åˆ°é¡¶éƒ¨">â†‘</button>
                        <button class="scroll-btn" onclick="scrollToBottom('gifts-container')" title="æ»šåŠ¨åˆ°åº•éƒ¨">â†“</button>
                    </div>
                    
                    <div class="gift-list" id="gift-list">
                        {% if recent_gifts %}
                            {% for gift in recent_gifts %}
                            <div class="gift-item" data-id="{{ gift.id|default:forloop.counter }}">
                                <span class="gift-user">{{ gift.username|default:"åŒ¿åç”¨æˆ·" }}</span>
                                <span class="gift-info">
                                    é€å‡º {{ gift.gift_name|default:"ç¤¼ç‰©" }} x{{ gift.num|default:1 }}
                                    ({{ gift.price|default:0 }}é‡‘ç“œå­)
                                </span>
                                <span class="gift-time">{{ gift.timestamp|default:"æœªçŸ¥æ—¶é—´" }}</span>
                            </div>
                            {% endfor %}
                        {% else %}
                            <div class="empty-state" id="gifts-empty">
                                ğŸ æš‚æ— ç¤¼ç‰©æ•°æ®<br>
                                <small>ç­‰å¾…å®æ—¶æ•°æ®æˆ–æ£€æŸ¥æ•°æ®æ”¶é›†å™¨çŠ¶æ€</small>
                            </div>
                        {% endif %}
                    </div>
                </div>
                
                <div class="last-update" id="gifts-last-update">
                    æœ€åæ›´æ–°: <span id="gifts-update-time">{{ now|date:"H:i:s" }}</span>
                </div>
            </div>
        </div>

        <!-- æ“ä½œç»“æœ -->
        <div id="operation-result"></div>

        <!-- é”™è¯¯ä¿¡æ¯ -->
        {% if error %}
        <div class="message-box error">
            <strong>âŒ åŠ è½½é”™è¯¯:</strong> {{ error }}
        </div>
        {% endif %}
    </div>

    {% csrf_token %}
    
    <script>
        // ===== å…¨å±€é…ç½®å’ŒçŠ¶æ€ =====
        const RoomConfig = {
            roomId: {{ room_id }},
            refreshInterval: 2000,
            maxDanmaku: 50,
            maxGifts: 30,
            animationDuration: 300,
            debugMode: true,
            autoScrollTop: true,
            showScrollControls: true,
            highlightNew: true
        };
        
        const RoomState = {
            autoRefreshEnabled: true,
            updateInterval: null,
            isUpdating: false,
            updateCount: 0,
            newDanmakuCount: 0,
            newGiftsCount: 0,
            lastDanmakuIds: new Set(),
            lastGiftIds: new Set(),
            lastStats: {
                danmaku_count: 0,
                gift_count: 0,
                popularity: 0
            },
            scrollPositions: {
                danmaku: 0,
                gifts: 0
            }
        };
        
        // ===== å·¥å…·å‡½æ•° =====
        function debugLog(message, data = null) {
            if (RoomConfig.debugMode) {
                console.log(`[RoomDetail] ${message}`, data || '');
            }
        }
        
        function getCSRFToken() {
            const token = document.querySelector('[name=csrfmiddlewaretoken]');
            return token ? token.value : '';
        }
        
        function showMessage(message, type = 'info', duration = 5000) {
            const resultDiv = document.getElementById('operation-result');
            if (!resultDiv) return;
            
            resultDiv.className = `message-box ${type}`;
            resultDiv.innerHTML = message;
            resultDiv.style.display = 'block';
            
            if (duration > 0) {
                setTimeout(() => {
                    resultDiv.style.display = 'none';
                }, duration);
            }
        }
        
        function updateCounter(counterId, increment = 1) {
            const element = document.getElementById(counterId);
            if (element) {
                const current = parseInt(element.textContent.split(': ')[1]) || 0;
                element.textContent = element.textContent.split(': ')[0] + ': ' + (current + increment);
            }
        }
        
        function setLoadingState(elementId, isLoading) {
            const element = document.getElementById(elementId);
            if (element) {
                element.style.display = isLoading ? 'inline-block' : 'none';
            }
        }
        
        function formatTime(timestamp) {
            try {
                const date = new Date(timestamp);
                return date.toLocaleTimeString();
            } catch {
                return timestamp || 'æœªçŸ¥æ—¶é—´';
            }
        }
        
        function animateStatUpdate(containerId, numberId) {
            const container = document.getElementById(containerId);
            const number = document.getElementById(numberId);
            
            if (container && number) {
                container.classList.add('updated');
                number.classList.add('updated');
                
                setTimeout(() => {
                    container.classList.remove('updated');
                    number.classList.remove('updated');
                }, 1000);
            }
        }
        
        // ===== æ»šåŠ¨æ§åˆ¶å‡½æ•° =====
        function scrollToTop(containerId) {
            const container = document.getElementById(containerId);
            if (container) {
                container.scrollTop = 0;
                debugLog(`${containerId} æ»šåŠ¨åˆ°é¡¶éƒ¨`);
            }
        }
        
        function scrollToBottom(containerId) {
            const container = document.getElementById(containerId);
            if (container) {
                container.scrollTop = container.scrollHeight;
                debugLog(`${containerId} æ»šåŠ¨åˆ°åº•éƒ¨`);
            }
        }
        
        function showScrollIndicator(containerId, message = 'æ–°æ¶ˆæ¯å·²ç½®é¡¶') {
            const indicator = document.getElementById(containerId.replace('-container', '-scroll-indicator'));
            if (indicator) {
                indicator.textContent = message;
                indicator.classList.add('show');
                setTimeout(() => {
                    indicator.classList.remove('show');
                }, 2000);
            }
        }
        
        function updateScrollControls() {
            const showControls = document.getElementById('show-scroll-controls').checked;
            const controls = document.querySelectorAll('.scroll-controls');
            controls.forEach(control => {
                control.style.display = showControls ? 'flex' : 'none';
            });
        }
        
        // ===== APIè°ƒç”¨å‡½æ•° =====
        async function apiCall(url, options = {}) {
            debugLog(`APIè°ƒç”¨: ${url}`);
            
            const defaultOptions = {
                method: 'GET',
                headers: {
                    'X-CSRFToken': getCSRFToken(),
                    'Content-Type': 'application/json',
                },
                ...options
            };
            
            try {
                const response = await fetch(url, defaultOptions);
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                
                const data = await response.json();
                debugLog(`APIå“åº”: ${url}`, { success: data.success, hasData: !!data.data });
                
                return { success: true, data };
            } catch (error) {
                debugLog(`APIè°ƒç”¨å¤±è´¥: ${url}`, { error: error.message });
                return { success: false, error: error.message };
            }
        }
        
        // ===== æ•°æ®æ›´æ–°å‡½æ•° =====
        async function updateRoomStats() {
            debugLog('æ›´æ–°æˆ¿é—´ç»Ÿè®¡');
            setLoadingState('stats-loading', true);
            
            const result = await apiCall(`/live/api/room/${RoomConfig.roomId}/stats/`);
            
            if (result.success && result.data.success && result.data.data) {
                const stats = result.data.data.stats || {};
                const roomInfo = result.data.data.room_info || {};
                
                // æ£€æŸ¥æ•°æ®å˜åŒ–å¹¶æ›´æ–°
                const updates = [
                    { id: 'danmaku-count', value: stats.danmaku_count || 0, containerId: 'stat-danmaku-count' },
                    { id: 'gift-count', value: stats.gift_count || 0, containerId: 'stat-gift-count' },
                    { id: 'popularity', value: roomInfo.popularity || 0, containerId: 'stat-popularity' }
                ];
                
                updates.forEach(update => {
                    const element = document.getElementById(update.id);
                    if (element) {
                        const oldValue = parseInt(element.textContent.replace(/,/g, ''));
                        const newValue = update.value;
                        
                        if (oldValue !== newValue) {
                            element.textContent = newValue.toLocaleString();
                            animateStatUpdate(update.containerId, update.id);
                        }
                    }
                });
                
                // æ›´æ–°æ—¶é—´æ˜¾ç¤º
                const updateTime = document.getElementById('stats-last-update');
                if (updateTime) {
                    updateTime.textContent = `æ›´æ–°äº ${new Date().toLocaleTimeString()}`;
                }
                
                RoomState.lastStats = {
                    danmaku_count: stats.danmaku_count || 0,
                    gift_count: stats.gift_count || 0,
                    popularity: roomInfo.popularity || 0
                };
                
                debugLog('æˆ¿é—´ç»Ÿè®¡æ›´æ–°å®Œæˆ', stats);
                return true;
            } else {
                debugLog('æˆ¿é—´ç»Ÿè®¡æ›´æ–°å¤±è´¥', result);
                return false;
            }
            
            setLoadingState('stats-loading', false);
        }
        
        async function updateDanmaku() {
            debugLog('æ›´æ–°å¼¹å¹•æ•°æ®');
            setLoadingState('danmaku-loading', true);
            
            const result = await apiCall(`/live/api/room/${RoomConfig.roomId}/danmaku/?limit=${RoomConfig.maxDanmaku}`);
            
            if (result.success && result.data.success && result.data.data) {
                const danmakuList = result.data.data.danmaku || [];
                const container = document.getElementById('danmaku-list');
                const emptyState = document.getElementById('danmaku-empty');
                const countDisplay = document.getElementById('danmaku-count-display');
                const autoScrollTop = document.getElementById('auto-scroll-top').checked;
                const highlightNew = document.getElementById('highlight-new').checked;
                
                if (danmakuList.length > 0) {
                    // æ£€æŸ¥æ–°å¼¹å¹•
                    let newCount = 0;
                    const currentIds = new Set();
                    let hasNewItems = false;
                    
                    // æŒ‰æ—¶é—´æ’åºï¼Œæœ€æ–°çš„åœ¨å‰
                    danmakuList.sort((a, b) => {
                        const timeA = new Date(a.timestamp || 0).getTime();
                        const timeB = new Date(b.timestamp || 0).getTime();
                        return timeB - timeA; // é™åºï¼Œæ–°çš„åœ¨å‰
                    });
                    
                    const danmakuHtml = danmakuList.map((danmaku, index) => {
                        const danmakuId = danmaku.id || `${danmaku.timestamp}_${index}`;
                        currentIds.add(danmakuId);
                        
                        const isNew = !RoomState.lastDanmakuIds.has(danmakuId);
                        if (isNew) {
                            newCount++;
                            hasNewItems = true;
                        }
                        
                        const newClass = (isNew && highlightNew) ? 'new' : '';
                        
                        return `
                            <div class="danmaku-item ${newClass}" data-id="${danmakuId}">
                                <span class="danmaku-user">${danmaku.username || 'åŒ¿åç”¨æˆ·'}</span>
                                <span class="danmaku-message">${danmaku.message || ''}</span>
                                <span class="danmaku-time">${formatTime(danmaku.timestamp)}</span>
                            </div>
                        `;
                    }).join('');
                    
                    // ä¿å­˜å½“å‰æ»šåŠ¨ä½ç½®
                    const danmakuContainer = document.getElementById('danmaku-container');
                    const wasAtTop = danmakuContainer.scrollTop === 0;
                    
                    container.innerHTML = danmakuHtml;
                    RoomState.lastDanmakuIds = currentIds;
                    
                    if (newCount > 0) {
                        RoomState.newDanmakuCount += newCount;
                        updateCounter('new-danmaku-counter', newCount);
                        
                        // å¦‚æœå¼€å¯è‡ªåŠ¨ç½®é¡¶ä¸”æœ‰æ–°æ¶ˆæ¯
                        if (autoScrollTop && hasNewItems) {
                            scrollToTop('danmaku-container');
                            showScrollIndicator('danmaku-container', `${newCount} æ¡æ–°å¼¹å¹•å·²ç½®é¡¶`);
                        }
                    }
                    
                    // éšè—ç©ºçŠ¶æ€
                    if (emptyState) {
                        emptyState.style.display = 'none';
                    }
                    
                } else {
                    if (emptyState) {
                        emptyState.style.display = 'block';
                    }
                }
                
                // æ›´æ–°è®¡æ•°æ˜¾ç¤º
                if (countDisplay) {
                    countDisplay.textContent = `(${danmakuList.length})`;
                }
                
                // æ›´æ–°æ—¶é—´
                const updateTime = document.getElementById('danmaku-update-time');
                if (updateTime) {
                    updateTime.textContent = new Date().toLocaleTimeString();
                }
                
                debugLog('å¼¹å¹•æ•°æ®æ›´æ–°å®Œæˆ', { count: danmakuList.length, newCount });
                return true;
            } else {
                debugLog('å¼¹å¹•æ•°æ®æ›´æ–°å¤±è´¥', result);
                return false;
            }
            
            setLoadingState('danmaku-loading', false);
        }
        
        async function updateGifts() {
            debugLog('æ›´æ–°ç¤¼ç‰©æ•°æ®');
            setLoadingState('gifts-loading', true);
            
            const result = await apiCall(`/live/api/room/${RoomConfig.roomId}/gifts/?limit=${RoomConfig.maxGifts}`);
            
            if (result.success && result.data.success && result.data.data) {
                const giftsList = result.data.data.gifts || [];
                const container = document.getElementById('gift-list');
                const emptyState = document.getElementById('gifts-empty');
                const countDisplay = document.getElementById('gifts-count-display');
                const autoScrollTop = document.getElementById('auto-scroll-top').checked;
                const highlightNew = document.getElementById('highlight-new').checked;
                
                if (giftsList.length > 0) {
                    // æ£€æŸ¥æ–°ç¤¼ç‰©
                    let newCount = 0;
                    const currentIds = new Set();
                    let hasNewItems = false;
                    
                    // æŒ‰æ—¶é—´æ’åºï¼Œæœ€æ–°çš„åœ¨å‰
                    giftsList.sort((a, b) => {
                        const timeA = new Date(a.timestamp || 0).getTime();
                        const timeB = new Date(b.timestamp || 0).getTime();
                        return timeB - timeA; // é™åºï¼Œæ–°çš„åœ¨å‰
                    });
                    
                    const giftsHtml = giftsList.map((gift, index) => {
                        const giftId = gift.id || `${gift.timestamp}_${index}`;
                        currentIds.add(giftId);
                        
                        const isNew = !RoomState.lastGiftIds.has(giftId);
                        if (isNew) {
                            newCount++;
                            hasNewItems = true;
                        }
                        
                        const newClass = (isNew && highlightNew) ? 'new' : '';
                        
                        return `
                            <div class="gift-item ${newClass}" data-id="${giftId}">
                                <span class="gift-user">${gift.username || 'åŒ¿åç”¨æˆ·'}</span>
                                <span class="gift-info">
                                    é€å‡º ${gift.gift_name || 'ç¤¼ç‰©'} x${gift.num || 1}
                                    (${gift.price || 0}é‡‘ç“œå­)
                                </span>
                                <span class="gift-time">${formatTime(gift.timestamp)}</span>
                            </div>
                        `;
                    }).join('');
                    
                    // ä¿å­˜å½“å‰æ»šåŠ¨ä½ç½®
                    const giftsContainer = document.getElementById('gifts-container');
                    const wasAtTop = giftsContainer.scrollTop === 0;
                    
                    container.innerHTML = giftsHtml;
                    RoomState.lastGiftIds = currentIds;
                    
                    if (newCount > 0) {
                        RoomState.newGiftsCount += newCount;
                        updateCounter('new-gifts-counter', newCount);
                        
                        // å¦‚æœå¼€å¯è‡ªåŠ¨ç½®é¡¶ä¸”æœ‰æ–°æ¶ˆæ¯
                        if (autoScrollTop && hasNewItems) {
                            scrollToTop('gifts-container');
                            showScrollIndicator('gifts-container', `${newCount} ä¸ªæ–°ç¤¼ç‰©å·²ç½®é¡¶`);
                        }
                    }
                    
                    // éšè—ç©ºçŠ¶æ€
                    if (emptyState) {
                        emptyState.style.display = 'none';
                    }
                    
                } else {
                    if (emptyState) {
                        emptyState.style.display = 'block';
                    }
                }
                
                // æ›´æ–°è®¡æ•°æ˜¾ç¤º
                if (countDisplay) {
                    countDisplay.textContent = `(${giftsList.length})`;
                }
                
                // æ›´æ–°æ—¶é—´
                const updateTime = document.getElementById('gifts-update-time');
                if (updateTime) {
                    updateTime.textContent = new Date().toLocaleTimeString();
                }
                
                debugLog('ç¤¼ç‰©æ•°æ®æ›´æ–°å®Œæˆ', { count: giftsList.length, newCount });
                return true;
            } else {
                debugLog('ç¤¼ç‰©æ•°æ®æ›´æ–°å¤±è´¥', result);
                return false;
            }
            
            setLoadingState('gifts-loading', false);
        }
        
        // ===== ä¸»è¦æ§åˆ¶å‡½æ•° =====
        async function refreshAllData() {
            if (RoomState.isUpdating) {
                debugLog('è·³è¿‡æ›´æ–°ï¼šå·²æœ‰æ›´æ–°åœ¨è¿›è¡Œä¸­');
                return;
            }
            
            RoomState.isUpdating = true;
            RoomState.updateCount++;
            
            updateCounter('update-counter');
            
            const lastUpdateTime = document.getElementById('last-update-time');
            if (lastUpdateTime) {
                lastUpdateTime.textContent = `æœ€åæ›´æ–°: ${new Date().toLocaleTimeString()}`;
            }
            
            debugLog(`å¼€å§‹ç¬¬${RoomState.updateCount}æ¬¡æ•°æ®åˆ·æ–°`);
            
            try {
                // å¹¶è¡Œæ‰§è¡Œæ‰€æœ‰æ›´æ–°
                const [statsResult, danmakuResult, giftsResult] = await Promise.allSettled([
                    updateRoomStats(),
                    updateDanmaku(),
                    updateGifts()
                ]);
                
                const successes = [statsResult, danmakuResult, giftsResult].filter(
                    r => r.status === 'fulfilled' && r.value
                ).length;
                
                debugLog(`æ•°æ®åˆ·æ–°å®Œæˆ`, { 
                    total: 3, 
                    success: successes,
                    statsOk: statsResult.status === 'fulfilled' && statsResult.value,
                    danmakuOk: danmakuResult.status === 'fulfilled' && danmakuResult.value,
                    giftsOk: giftsResult.status === 'fulfilled' && giftsResult.value
                });
                
                if (successes === 3) {
                    if (RoomState.updateCount % 20 === 0) { // æ¯20æ¬¡æ›´æ–°æ˜¾ç¤ºä¸€æ¬¡æˆåŠŸæ¶ˆæ¯
                        showMessage('âœ… æ•°æ®åˆ·æ–°å®Œæˆ', 'success', 2000);
                    }
                } else if (successes > 0) {
                    showMessage(`âš ï¸ éƒ¨åˆ†æ•°æ®æ›´æ–°å¤±è´¥ (${successes}/3)`, 'warning', 3000);
                } else {
                    showMessage('âŒ æ•°æ®åˆ·æ–°å¤±è´¥', 'error', 5000);
                }
                
            } catch (error) {
                debugLog('æ•°æ®åˆ·æ–°å¼‚å¸¸', { error: error.message });
                showMessage(`âŒ æ•°æ®åˆ·æ–°å¤±è´¥: ${error.message}`, 'error', 5000);
            } finally {
                RoomState.isUpdating = false;
            }
        }
        
        function clearAllData() {
            debugLog('æ¸…ç©ºæ˜¾ç¤ºæ•°æ®');
            
            // æ¸…ç©ºè®¡æ•°å™¨
            RoomState.newDanmakuCount = 0;
            RoomState.newGiftsCount = 0;
            RoomState.lastDanmakuIds.clear();
            RoomState.lastGiftIds.clear();
            
            // é‡ç½®è®¡æ•°å™¨æ˜¾ç¤º
            document.getElementById('new-danmaku-counter').textContent = 'æ–°å¼¹å¹•: 0';
            document.getElementById('new-gifts-counter').textContent = 'æ–°ç¤¼ç‰©: 0';
            
            showMessage('ğŸ—‘ï¸ æ˜¾ç¤ºæ•°æ®å·²æ¸…ç©º', 'info', 2000);
        }
        
        function toggleAutoRefresh() {
            RoomState.autoRefreshEnabled = !RoomState.autoRefreshEnabled;
            
            const btn = document.getElementById('auto-refresh-btn');
            const indicator = document.getElementById('refresh-indicator');
            
            if (RoomState.autoRefreshEnabled) {
                btn.textContent = 'â¸ï¸ æš‚åœ';
                btn.className = 'btn';
                indicator.className = 'refresh-indicator active';
                indicator.textContent = `â±ï¸ è‡ªåŠ¨åˆ·æ–°: ${RoomConfig.refreshInterval/1000}ç§’`;
                
                startAutoRefresh();
                showMessage('â–¶ï¸ è‡ªåŠ¨åˆ·æ–°å·²å¯åŠ¨', 'success', 2000);
                debugLog('è‡ªåŠ¨åˆ·æ–°å·²å¯åŠ¨');
            } else {
                btn.textContent = 'â–¶ï¸ å¯åŠ¨';
                btn.className = 'btn warning';
                indicator.className = 'refresh-indicator paused';
                indicator.textContent = 'â¸ï¸ è‡ªåŠ¨åˆ·æ–°å·²æš‚åœ';
                
                stopAutoRefresh();
                showMessage('â¸ï¸ è‡ªåŠ¨åˆ·æ–°å·²æš‚åœ', 'warning', 2000);
                debugLog('è‡ªåŠ¨åˆ·æ–°å·²æš‚åœ');
            }
        }
        
        function changeRefreshInterval() {
            const select = document.getElementById('refresh-interval');
            RoomConfig.refreshInterval = parseInt(select.value);
            
            const indicator = document.getElementById('refresh-indicator');
            if (RoomState.autoRefreshEnabled) {
                indicator.textContent = `â±ï¸ è‡ªåŠ¨åˆ·æ–°: ${RoomConfig.refreshInterval/1000}ç§’`;
                startAutoRefresh(); // é‡å¯å®šæ—¶å™¨
            }
            
            debugLog('åˆ·æ–°é—´éš”å·²æ›´æ”¹', { interval: RoomConfig.refreshInterval });
        }
        
        function startAutoRefresh() {
            stopAutoRefresh();
            
            RoomState.updateInterval = setInterval(() => {
                if (RoomState.autoRefreshEnabled && document.visibilityState === 'visible') {
                    refreshAllData();
                }
            }, RoomConfig.refreshInterval);
            
            debugLog('è‡ªåŠ¨åˆ·æ–°å®šæ—¶å™¨å·²å¯åŠ¨', { interval: RoomConfig.refreshInterval });
        }
        
        function stopAutoRefresh() {
            if (RoomState.updateInterval) {
                clearInterval(RoomState.updateInterval);
                RoomState.updateInterval = null;
                debugLog('è‡ªåŠ¨åˆ·æ–°å®šæ—¶å™¨å·²åœæ­¢');
            }
        }
        
        // ===== äº‹ä»¶ç›‘å¬å™¨ =====
        document.addEventListener('DOMContentLoaded', function() {
            debugLog('æˆ¿é—´è¯¦æƒ…é¡µé¢åŠ è½½å®Œæˆ', { roomId: RoomConfig.roomId });
            
            // åˆå§‹åŒ–ç°æœ‰å¼¹å¹•å’Œç¤¼ç‰©çš„ID
            document.querySelectorAll('.danmaku-item').forEach(item => {
                const id = item.getAttribute('data-id');
                if (id) RoomState.lastDanmakuIds.add(id);
            });
            
            document.querySelectorAll('.gift-item').forEach(item => {
                const id = item.getAttribute('data-id');
                if (id) RoomState.lastGiftIds.add(id);
            });
            
            // åˆå§‹åŒ–è®¾ç½®
            updateScrollControls();
            
            // ç»‘å®šè®¾ç½®å˜æ›´äº‹ä»¶
            document.getElementById('auto-scroll-top').addEventListener('change', function() {
                RoomConfig.autoScrollTop = this.checked;
                debugLog('è‡ªåŠ¨ç½®é¡¶è®¾ç½®å·²æ›´æ”¹', { enabled: this.checked });
            });
            
            document.getElementById('show-scroll-controls').addEventListener('change', updateScrollControls);
            
            document.getElementById('highlight-new').addEventListener('change', function() {
                RoomConfig.highlightNew = this.checked;
                debugLog('æ–°æ¶ˆæ¯é«˜äº®è®¾ç½®å·²æ›´æ”¹', { enabled: this.checked });
            });
            
            // å»¶è¿Ÿå¯åŠ¨è‡ªåŠ¨åˆ·æ–°
            setTimeout(() => {
                debugLog('å¼€å§‹åˆå§‹åŒ–æ•°æ®åŠ è½½');
                refreshAllData();
                startAutoRefresh();
            }, 1000);
        });
        
        document.addEventListener('visibilitychange', function() {
            const isVisible = document.visibilityState === 'visible';
            debugLog('é¡µé¢å¯è§æ€§å˜åŒ–', { visible: isVisible });
            
            if (isVisible && RoomState.autoRefreshEnabled) {
                setTimeout(refreshAllData, 100);
            }
        });
        
        window.addEventListener('beforeunload', function() {
            debugLog('é¡µé¢å³å°†å¸è½½');
            stopAutoRefresh();
        });
        
        window.addEventListener('error', function(e) {
            debugLog('JavaScripté”™è¯¯', { 
                message: e.message, 
                filename: e.filename, 
                lineno: e.lineno 
            });
            showMessage(`âŒ é¡µé¢é”™è¯¯: ${e.message}`, 'error', 5000);
        });
        
        // å¯¼å‡ºå…¨å±€å‡½æ•°ä¾›è°ƒè¯•ä½¿ç”¨
        window.RoomDebug = {
            RoomState,
            RoomConfig,
            refreshAllData,
            clearAllData,
            scrollToTop,
            scrollToBottom,
            debugLog
        };
        
        debugLog('æˆ¿é—´è¯¦æƒ…è„šæœ¬åˆå§‹åŒ–å®Œæˆ', RoomConfig);
    </script>
</body>
</html>